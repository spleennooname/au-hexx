!function(n){var r={};function e(t){if(r[t])return r[t].exports;var o=r[t]={i:t,l:!1,exports:{}};return n[t].call(o.exports,o,o.exports,e),o.l=!0,o.exports}e.m=n,e.c=r,e.d=function(n,r,t){e.o(n,r)||Object.defineProperty(n,r,{configurable:!1,enumerable:!0,get:t})},e.n=function(n){var r=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(r,"a",r),r},e.o=function(n,r){return Object.prototype.hasOwnProperty.call(n,r)},e.p="/dist/",e(e.s=0)}([function(n,r,e){e(1),e(2);var t=document.querySelector("#gl").getContext("webgl"),o=twgl.createProgramInfo(t,["vs","fs"]),a=twgl.createBufferInfoFromArrays(t,{position:[-1,-1,0,1,-1,0,-1,1,0,-1,1,0,1,-1,0,1,1,0]}),i=1e3/60,c=window.performance.now(),p=0,s=window.innerWidth,f=window.innerHeight;t.useProgram(o.program),function n(r){requestAnimationFrame(n);var e=(p=window.performance.now())-c;if(e>i){c=p-e%i,twgl.resizeCanvasToDisplaySize(t.canvas),t.viewport(0,0,s,f);var l={uTime:.001*r,iResolution:[s,f]};twgl.setBuffersAndAttributes(t,o,a),twgl.setUniforms(o,l),twgl.drawBufferInfo(t,a)}}()},function(n,r){n.exports="precision mediump float;\n\nattribute vec4 position;\n\nvoid main() {\n gl_Position = position;\n}\n"},function(n,r){n.exports=" precision mediump float;\n\n    uniform vec2 iResolution;\n    uniform float uTime;\n\n    #define PI 3.141592653589\n    #define tick() ( uTime * 0.001 )\n    #define COLOR_GLOW vec3(1.0, 0.4, 0.4)\n    #define LOOK_AT vec3(0., 0., 0.)\n    #define UP vec3(0.,0., .5)\n    #define BACKGROUND 0.75\n\n    struct Ray {\n      vec3 org;\n      vec3 dir;\n    };\n\n    mat3 rotation;\n\n    mat3 rotateX(float a){\n        return mat3(1.,0.,0.,\n                    0.,cos(a), -sin(a),\n                    0.,sin(a), cos(a));\n    }\n\n    mat3 rotateY(float a){\n        return mat3(cos(a), 0., -sin(a),\n                    0.,1.,0.,\n                    sin(a), 0., cos(a));\n    }\n\n    float hash(float f)\n    {\n        return fract(sin(f*32.34182) * 43758.5400);\n    }\n\n    float hash(vec2 p)\n    {\n        return fract(sin(dot(p.xy , vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    vec3 hsv2rgb(vec3 c)\n    {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n    vec3 grid(vec3 dir, bool vert){\n        \n        vec2 p = dir.xy / max(0.001, abs(dir.z) );\n        \n        p *= 2.;\n        \n        float time = uTime * 0.1;\n\n        p.y *= 0.1;\n        p.y += time * 10.3;\n\n        vert = hash(floor(p.y/5. + 0.5)) < 0.5 ? vert : !vert;\n        p += 0.5;\n        \n        float h = hash(floor(p*sign(dir.z)));\n\n        float h2 = hash( floor(p.y/1.) );\n        float h3 = hash( floor(p.y/1.) + sign(dir.z)) ;\n\n        float band = abs(p.x) < 2. + floor(10.*h3*h3) ? 1. : 0.;\n        \n        p = mod(p, vec2(1.));\n        p -= 0.5;\n\n        float f = h2 < 0.5 ? smoothstep(0.6, 0.0,length(p))*6. : 2.;\n        \n        h = h < h2/1.2 + 0.1 && vert ? 1. : 0.;\n        \n        vec3 acc =  vec3( 1., h2/10. + time/20.,  1.)  * h * band * 1. * f;\n        //vec3 acc = vec3( time/10., time/20., 1.) * h * band *3. * f; \n        \n        return acc * pow( abs(dir.z), .25);\n\n    }\n\n    vec3 background(vec3 dir){\n      return BACKGROUND * ( grid(dir.yxz, true) + grid( dir.yxz, true) );\n      //return vec3(0.);\n    }\n\n    //original\n    // float box(vec3 p, vec3 w){\n    //     p = abs(p);\n    //     return max(p.x-w.x, max(p.y-w.y, p.z-w.z));\n    // }\n\n    // float box(vec3 p, vec3 w){\n    //     p = abs(p);\n    //     float box = max( p.x - w.x, max( 1.0*p.y - w.y, min(p.z - w.z, w.x ) ) );\n    //     return box;\n    // }\n\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        vec3 q = abs(p);\n        return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n    }\n\n    float udBox( vec3 p, vec3 b )\n    {\n        p = abs(p);\n      return length( max( p.x - b.x*0.5, 1.5 * p.y - b.y) );\n    }\n\n    float sdTriPrism( vec3 p, vec2 h )\n    {\n        vec3 q = abs(p);\n        return max( q.z-h.y, max(q.x*0.866025 + p.y*0.866025, -p.y) - h.y*0.5 );\n    }\n\n    float box(vec3 p, vec3 w){\n        p = abs(p);\n        //return max(p.x-w.x, max(p.y-w.y, p.z-w.z ) );\n        //return max(p.x-w.x, max(p.y-w.y, min(p.x-w.x, p.y) ) );\n        return length(max(abs(p)-w,0.0));\n\n    }\n\n    float map(vec3 p){\n        float time = uTime * 0.005;\n        for (int i = 0; i < 3; i++){\n            p = abs( p*rotation + vec3(0.75, .3, .0));\n            p.x -= (sin(time/5.) + 1.)/3.;\n            p.y -= (sin(time/5.) + 1.)/3.;\n            p.z -= (sin(time/5.) + 1.)/3.;\n        }\n        //original: vec3(0.8, 4.4, 0.4)\n      // return box(p, vec3(0.95, 5., 1.75));\n        //return udBox(p, vec3(0.95, 5., 1.75) );\n      return sdTriPrism(p, vec2(1.25, 2.5) );\n    }\n\n    vec3 normal(vec3 pos)\n    {\n      vec3 eps = vec3( 0.002, 0.0, 0.0 );\n      vec3 nor = vec3(map(pos+eps.xyy) - map(pos-eps.xyy),\n                        map(pos+eps.yxy) - map(pos-eps.yxy),\n                        map(pos+eps.yyx) - map(pos-eps.yyx) );\n      return normalize(nor);\n    }\n\n    vec3 selfReflect(Ray ray){\n        float dist = 0.01;\n        vec3 pos;\n        float minDist = 1000.;\n        float curMap;\n        for (int i = 0; i < 30; i++){\n            pos = ray.org + dist*ray.dir;\n            curMap = map(pos);\n            dist+=curMap;\n            if(i > 7){\n                minDist = min(minDist,curMap);\n            }\n        }\n        float m = map(pos);\n        if (m < 0.01){\n            vec3 n = normal(pos);\n            vec3 r = reflect(ray.dir, n);\n            vec3 refl = background(r);\n            float rf = 0.8 - abs(dot(ray.dir, n)) * .4;\n            rf *= rf;\n            return refl*rf*1.3; \n        }\n        float glow = 0.04/minDist;\n\n        return background(ray.dir)*0.5 + glow * COLOR_GLOW;\n        //return glow * COLOR_GLOW;\n    }\n\n\n    Ray createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect){\n\n      Ray ray;\n      ray.org = center;\n\n      vec3 dir = normalize(lookAt - center);\n      up = normalize(up - dir*dot(dir,up));\n      \n        vec3 right = cross(dir, up);\n      uv = 2.*uv - vec2(1.);\n      \n        fov = fov * PI / 180.;\n\n      ray.dir = dir + tan(fov/2.) * right * uv.x + tan(fov/2.) / aspect * up * uv.y;\n      ray.dir = normalize(ray.dir);\t\n      \n        return ray;\n    }\n\n    vec3 render(Ray ray){\n\n        float dist = 0.;\n        \n        vec3 pos;\n        float minDist = 1000.;\n        float curMap;\n\n        for (int i = 0; i < 30; i++){\n            pos = ray.org + dist*ray.dir;\n            curMap = map(pos);\n            dist += curMap;\n            minDist = min(minDist,curMap);\n        }\n        \n        float m = map(pos);\n        \n        if (m < 0.001){\n            vec3 n = normal(pos);\n            vec3 r = reflect(ray.dir, n);\n            vec3 refl = selfReflect(Ray(pos, r));\n            float rf = 1.0-abs(dot(ray.dir, n) )*.4;\n            rf *= rf;\n            return refl*rf*1.5; \n        }\n\n        float glow = 0.03/minDist;\n\n        return background(ray.dir)*0.5 + glow * COLOR_GLOW;\n    }\n\n    void main( void ) {\n        \n        vec2 uv = gl_FragCoord.xy / iResolution;\n        vec2 p = uv;\n\n        float time = uTime;\n\n        vec3 cameraPos = vec3(-8.,2.*sin(time/10.),-4.*sin(time/4.));\n        //float aspect = size.x/size.y;\n\n        float xt = floor(time/8.) + clamp(fract(time/2.)*20.,0.,1.);\n        float yt = floor(time/2.) + clamp(fract(time/2.)*5.,0.,1.);\n        \n        rotation = rotateX(xt*PI/4.)*rotateY(yt*PI/2.);\n      \n        Ray ray = createRay(cameraPos, LOOK_AT, UP, p, 110., (iResolution.x/ iResolution.y) );\n\n        vec3 col = render(ray);\n\n        //col = pow(col, vec3(1.5));\n\n    \n        vec2 coord = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n        float rf = sqrt(dot(coord, coord)) * .85;\n        float rf2_1 = rf * rf + 1.0;\n        float vg = 1.0 / (rf2_1 * rf2_1);\n      \n        gl_FragColor = vec4(col * vg, 1.0);\n        \n\n    }"}]);